import { M } from "../maybe";
type FromIterator<A, S extends Iterable<A> = Iterable<A>, T extends Iterable<A> = Iterable<A>> = (source: S) => T;
declare class LazyIterator<I> implements Iterable<I> {
    private readonly source;
    private readonly operations;
    private readonly isCycled;
    static from<I>(iterable: Iterable<I> | LazyIterator<I>): LazyIterator<I>;
    private static withOperation;
    private constructor();
    append(item: I): LazyIterator<I>;
    chain(...otherIterators: Array<Iterable<I>>): LazyIterator<I>;
    compact<I>(this: LazyIterator<I | undefined>): LazyIterator<I>;
    compress(mask: number[] | boolean[]): LazyIterator<I>;
    cycle(): LazyIterator<I>;
    enumarate(): LazyIterator<[number, I]>;
    except(other: LazyIterator<I>): LazyIterator<I>;
    filter<T extends I>(predicate: (i: I) => i is T): LazyIterator<T>;
    filter(predicate: (i: I) => boolean): LazyIterator<I>;
    filterMap<T>(predicateMapper: (i: I) => M.Maybe<T>): LazyIterator<T>;
    filterMap<T>(predicateMapper: (i: I) => T | undefined): LazyIterator<T>;
    flatten(this: LazyIterator<I | LazyIterator<I>>): LazyIterator<I>;
    flatMap<N>(fn: (i: I) => LazyIterator<N>): LazyIterator<N>;
    intersect(other: LazyIterator<I>): LazyIterator<I>;
    map<T>(fn: (i: I) => T): LazyIterator<T>;
    permutations(): LazyIterator<[I, I]>;
    prepend(item: I): LazyIterator<I>;
    reverse(): LazyIterator<I>;
    skip(n: number): LazyIterator<I>;
    scan<A>(fn: (a: A, i: I) => A, accumulator: A): LazyIterator<A>;
    skipWhile(predicate: (i: I) => boolean): LazyIterator<I>;
    slice(start?: number, end?: number): LazyIterator<I>;
    stepBy(step: number): LazyIterator<I>;
    take(n: number): LazyIterator<I>;
    takeWhile(predicate: (i: I) => boolean): LazyIterator<I>;
    unique(): LazyIterator<I>;
    zip<T>(other: LazyIterator<T>): LazyIterator<[I, T]>;
    collect(fromIterator?: FromIterator<I>): Iterable<I>;
    [Symbol.iterator](): Iterator<I>;
    forEach(fn: (i: I) => void | M.Maybe<void>): void;
    all<T extends I>(this: LazyIterator<I>, predicate: (i: I) => i is T): this is LazyIterator<T>;
    all(predicate: (i: I) => boolean): boolean;
    any(predicate: (i: I) => boolean): boolean;
    count(): number;
    contains(elem: I): boolean;
    find<T extends I>(predicate: (i: I) => i is T): M.Maybe<T>;
    find<T extends I>(predicate: (i: I) => i is T, withoutMaybe: false): M.Maybe<T>;
    find<T extends I>(predicate: (i: I) => i is T, withoutMaybe: true): T | undefined;
    find(predicate: (i: I) => boolean): M.Maybe<I>;
    find(predicate: (i: I) => boolean, withoutMaybe: false): M.Maybe<I>;
    find(predicate: (i: I) => boolean, withoutMaybe: true): I | undefined;
    findMap<T>(predicateMapper: (i: I) => M.Maybe<T> | T | undefined): M.Maybe<I>;
    findMap<T>(predicateMapper: (i: I) => M.Maybe<T> | T | undefined, withoutMaybe: false): M.Maybe<T>;
    findMap<T>(predicateMapper: (i: I) => M.Maybe<T> | T | undefined, withoutMaybe: true): I | undefined;
    first(): M.Maybe<I>;
    first(withoutMaybe: false): M.Maybe<I>;
    first(withoutMaybe: true): I | undefined;
    fold(fn: (a: I, i: I) => I): I;
    fold<A>(fn: (a: A, i: I) => A, accumulator: A): A;
    isEmpty(): boolean;
    last(): M.Maybe<I>;
    last(withoutMaybe: false): M.Maybe<I>;
    last(withoutMaybe: true): I | undefined;
    max(this: LazyIterator<number>): M.Maybe<I>;
    max(f: (i: I) => number): M.Maybe<I>;
    max(f: (i: I) => number, withoutMaybe: false): M.Maybe<I>;
    max(f: (i: I) => number, withoutMaybe: true): I | undefined;
    min(this: LazyIterator<number>): M.Maybe<I>;
    min(f?: (i: I) => number): M.Maybe<I>;
    min(f: (i: I) => number, withoutMaybe: false): M.Maybe<I>;
    min(f: (i: I) => number, withoutMaybe: true): I | undefined;
    nth(n: number): M.Maybe<I>;
    nth(n: number, withoutMaybe: false): M.Maybe<I>;
    nth(n: number, withoutMaybe: true): I | undefined;
    partion<T extends I>(predicate: (i: I) => i is T): [T[], I[]];
    partion(predicate: (i: I) => boolean): [I[], I[]];
    position(predicate: (i: I) => boolean): M.Maybe<number>;
    position(predicate: (i: I) => boolean, withoutMaybe: false): M.Maybe<number>;
    position(predicate: (i: I) => boolean, withoutMaybe: true): number | undefined;
    product(this: LazyIterator<number>): number;
    sum(this: LazyIterator<number>): number;
    unzip<A, B>(this: LazyIterator<[A, B]>): [A[], B[]];
}
export declare const Iter: typeof LazyIterator;
export {};
//# sourceMappingURL=index.d.ts.map